# 动态规划问题（Dynamic Programming）
## 动态规划问题的一般形式就是求最值;
## 求解动态规划的核心问题是穷举;只有列出正确的「状态转移方程」，才能正确地穷举。
## 动态规划问题存在「重叠子问题」
```
明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。
```
基本框架
* ![avatar](fig/3.29DP.png)


```
3.29斐波那契数(509)
```
* 暴力递归；（状态转移方程递归）  f(n) = f(n-1) + f(n-2);
* 自顶向下递归； （用额外存储 +  递归）、
* ![avatar](fig/3.29Fib1.png)
* 自底向上递推； （用额外存储 +  递推）、
* ![avatar](fig/3.29Fib2.png)


```
3.29凑零钱(322)
```
* 明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。
* 明确 base case: amount=0 时， 算法返回0 不需要任何硬币
* 明确状态： 也就是原问题和子问题中会变化的变量 硬币数量无限且面值固定， 所以发生变化的是 amount
* 明确选择：，导致发生状态变化的行为： 也就是选择硬币，硬币的面值就是选择
* 明确dp函数的定义： 自顶向下：dp是一个递归的函数， 其中的参数就是变化的的量，也就是状态；返回值就是需要计算的量
* 所以我们可以这样定义 dp 函数：dp(n) 表示，输入一个目标金额 n，返回凑出目标金额 n 所需的最少硬币数量。
![avatar](fig/凑零钱.png)
暴力 + 自顶向下 + 自底向上
* 不过 dp 函数体现在函数参数，而 dp 数组体现在数组索引（自顶向下对应dp函数 + 自底向上dp数组）
* dp数组初始化时候 dp（amount+1， amount+1）因为凑成 amount 金额的硬币数最多只可能等于 amount


```
3.29最长递增子序列(300)
```
* 自底向上递推，数学归纳法，假设dp[i-1]成立的条件下，去推导dp[i]。
* 二分查找法


```
3.29俄罗斯套娃信封问题(354)
```
* 最长递增序列的二维情况
* 先按照w进行升序排列，再按照h进行降序，之后对height进行最长递增子序列即可 （h降序是因为 避免出现w相同时候，不满足条件）
* sort函数的应用  sort(v.begin(), v.end(), [](auto& a, auto&b){return 条件})返回值为真表示符合要求条件（a[0]< b[0] ||(a[0]==b[0]&&a[1]>b[1]) 
* 
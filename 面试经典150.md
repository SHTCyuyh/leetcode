# 数组/字符串
## 7.26
### 合并两个有序数组（88）
思路：原地修改，从后往前；注意处理边界条件
```
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i= m-1, j= n-1;
        int p = nums1.size() - 1;     
        while(i>=0 && j>=0){
            if(nums1[i] > nums2[j]){
                nums1[p] = nums1[i];
                i--;
                p--;
            }else{
                nums1[p] = nums2[j];
                j--;
                p--;
            }
        }
        while(j>=0){
            nums1[p] = nums2[j];
            j--;
            p--;
        }
    }
};
```

### 27. 移除元素
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
自己的思路：遇到删除的值就和末位交换（边界条件需要考虑清楚，其次可以调用swap函数）
```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int j = nums.size() - 1;
        for (int i = 0; i <= j; i++) {
            if (nums[i] == val) {
                swap(nums[i], nums[res]);
                i--;
                res--;
            }
        }
        return j + 1;
    }
};
```
正确：快慢指针（原地修改数组，用快指针探路，慢指针存值，删除重复元素类似）；
```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow=0, fast=0;
        while(fast < nums.size()){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```


### 26. 删除有序数组中的重复项
给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。
原地修改： 快慢指针
`注意边界条件`
```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow=0, fast=0;
        while(fast<nums.size()){
            if(nums[fast] != nums[slow]){
                slow++;
                nums[slow] = nums[fast];
                
            }
            fast++;
        }
        return slow+1;
    }
};
```

### 80. 删除有序数组中的重复项 II
给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。
(思路：用一个flag记录出现次数)
```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int count = 0;
        int slow=0,fast=0;
        while(fast<nums.size()){
            if(nums[slow] != nums[fast]){
                slow++;
                nums[slow] = nums[fast];
            }else if(slow < fast && count<2){
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
            count++;
            if(fast<nums.size() && nums[fast]!= nums[fast-1]){
                count = 0;
            }
                
        }
        return slow+1;
    }
};
```

### 169. 多数元素
给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
(思路：set)
```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int n:nums){
            mp[n]++;
            if(mp[n]>int(nums.size()/2))
                return n;
        }
        return 0;
    }
};
```

(进阶：粒子的带点性)
```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int count = 0;
        int target;
        for(int n:nums){
            if(count == 0){
                target = n;
                count = 1;
            }else if(n == target){
                count++;
            }else{
                count--;
            }
        }
        return target;
    }
};

```
### 189. 轮转数组
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数
(思路：迭代器切割,`注意k需要对n取余`)
`vector.assign(begin,end), vector.erase(position),vector.erase(begin,end)`
```
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        vector<int> temp = nums;
        k = k%nums.size();
        auto left_b = nums.begin();
        auto right = temp.end();
        auto new_b = temp.end()-k;
        nums.insert(left_b,new_b,right);
        nums.erase(nums.end()-k,nums.end());
    }
};
```

(其他思路：三次逆转【全部，前半，后半】)
(其他思路：用全新数组存nums[i + k) % n] = nums[i])
```
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> newArr(n);
        for (int i = 0; i < n; ++i) {
            newArr[(i + k) % n] = nums[i];
        }
        nums.assign(newArr.begin(), newArr.end());
    }
};
```


# 双指针
## 7.26
### 125. 验证回文串
如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。
`注意大小写的转化可以用加减法实现c = c-'A'+'a';`
`回文串的判定可以从两边往中间，也可以中间往两边，奇偶的情况可能需要讨论`
```
class Solution {
public:
    bool isPalindrome(string s) {
        string ss = "";
        for(char c:s){
            if(c >= 'a' && c <= 'z'){
                ss += c;
            }
            if(c >= '0' && c <= '9'){
                ss += c;
            }
            if(c >= 'A' && c <= 'Z'){
                c = c-'A'+'a';
                ss += c;
            }
        }
        int i= 0, j= ss.size()-1;
        while(i<j){
            if(ss[i] == ss[j]){
                i++;
                j--;
            }else{
                return false;
            }
        }
        return true;
    }
};
```
### 392. 判断子序列
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
```
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i=0,j=0;
        while(i<s.size() && j<t.size()){
            if(s[i] == t[j]){
                i++;
                j++;
            }else{
                j++;
            }
        }
        if(i == s.size()){
            return true;
        }
        return false;
    }
};
```

### 167. 两数之和 II - 输入有序数组
给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 
以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。
思路（1.暴力双指针：超时；2：用hash表去存值，但是没有利用输入的性质）
```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left=0,right=numbers.size()-1;
        vector<int> res(2);
        unordered_map<int, int> mp;
        for(int i=0;i<numbers.size();i++){
            if(mp.count(target-numbers[i])){
                // cout << target-numbers[i] << endl;
                res[0] = mp[target-numbers[i]]+1;
                res[1] = i+1;
                break;
            }else{
                mp[numbers[i]] = i;
            }
        }
        return res;
    }
};
```
左右指针，利用二分查找的思想
```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        for (int i = 0; i < numbers.size(); ++i) {
            int low = i + 1, high = numbers.size() - 1;
            while (low <= high) {
                int mid = (high - low) / 2 + low;
                if (numbers[mid] == target - numbers[i]) {
                    return {i + 1, mid + 1};
                } else if (numbers[mid] > target - numbers[i]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
        }
        return {-1, -1};
    }
};
```



# 滑动窗口
## 0726
### 209. 长度最小的子数组
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

思路：滑动窗口枚举所有满足条件的子数组，然后用全局变量维护最小长度。
其他思路：因为所有数都是正数，可以尝试使用前缀和+二分查找的方法
```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res=INT_MAX;
        int left=0,right=0;
        int sum = 0;
        while(right < nums.size()){
            sum += nums[right];
            right++;
            if(sum >= target){
                int len = right-left;
                res = min(len+1,res);
                // cout << sum << endl;
                while(sum >= target && left<=right){
                    sum -= nums[left];
                    left++;
                    res = min(right-left+1,res);
                }
            }
        }
        return res==INT_MAX?0:res;

    }
};
```

### 3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
思路：用一个set来记录窗口内的字符出现频率，用一个全局变量维护最长长度
`注意一些细节`
```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size()<1){
            return s.size();
        }
        int res = 1;
        unordered_map<char,int> window;
        int left=0,right=0;
        while(right<s.size()){
            char c = s[right];
            window[c]++;
            while(window[c]>1){
                char d = s[left];
                window[d]--;
                left++;
                res = max(res,right-left+1);
            }
            res = max(res,right-left+1);
            right++;
            
        }
        return res;
    }
};
```

# 矩阵
## 0726
### 36. 有效的数独
请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
(思路：遍历)
```
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int rows[9][9];
        int columns[9][9];
        int subboxes[3][3][9];
        
        memset(rows,0,sizeof(rows));
        memset(columns,0,sizeof(columns));
        memset(subboxes,0,sizeof(subboxes));
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c != '.') {
                    int index = c - '0' - 1;
                    rows[i][index]++;
                    columns[j][index]++;
                    subboxes[i / 3][j / 3][index]++;
                    if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
};
```
# 哈希表
## 0726
### 383. 赎金信
你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
如果可以，返回 true ；否则返回 false 。
（思路）：hash表记录出现的元素，验证
```
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map<char,int> mp;
        for(char c:magazine){
            mp[c]++;
        }
        for(char c:ransomNote){
            if(mp[c] == 0)
                return false;
            mp[c]--;
        }
        return true;
    }
};
```

### 205. 同构字符串
给定两个字符串 s 和 t ，判断它们是否是同构的。
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。
(用两个mp分别记录a->b,b->a的映射)
```
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        unordered_map<char,char> mp;
        unordered_map<char,char> mp2;
        for(int i=0;i<s.size();++i){
            char c = s[i];
            char d = t[i];
            if(!mp.count(c) && !mp2.count(d)){
                mp[c] = d;
                mp2[d] = c;
            }else{
                if(mp[c] != d || mp2[d] != c)
                    return false;
            }
        }
        return true;
    }
};
```

### 290. 单词规律
给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。
这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。
(用两个mp记录映射关系)
```
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        vector<string> ss;
        string temp = "";
       for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' ') {
                ss.push_back(temp);
                temp = "";
            } else {
                temp += s[i];
            }
        }
        ss.push_back(temp);

        unordered_map<char,string> p2s;
        unordered_set<string> set;
        if (pattern.size() != ss.size()) {
            return false;
        }
        for(int i=0;i<pattern.size();++i){
            if(!p2s.count(pattern[i])){
                if(set.count(ss[i])){
                    return false;
                }
                p2s[pattern[i]] = ss[i];
                set.insert(ss[i]);
            }else{
                if(p2s[pattern[i]] != ss[i])
                    return false;
            }
        }
        return true;
    }
};

```

### 242. 有效的字母异位词
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

 (思路，hash map存，判断最后是否为空)
 ```
class Solution {
public:
    bool isAnagram(string s, string t) {
        unordered_map<char,int> mp;
        for(char c:s){
            mp[c]++;
        }
        for(char c:t){
            if(!mp.count(c)){
                return false;
            }else{
                mp[c]--;
                if(mp[c]==0){
                    mp.erase(c);
                }
            }
        }
        if(mp.begin() != mp.end()){
            return false;
        }
        
        return 1;
    }
};
 ```
`优化方法，encode用数组记录每个字符出现次数`
```
class Solution {
public:
    // 判断字符串 s 和 t 是否为字母异位词
    bool isAnagram(string s, string t) {
        // 使用 encode 函数计算两个字符串中各字符出现的次数
        vector<int> count1 = encode(s);
        vector<int> count2 = encode(t);
        // 判断两个字符串中所有字符出现的数量是否相同
        for (int i = 0; i < count1.size(); i++) {
            if (count1[i] != count2[i]) {
                return false;
            }
        }
        return true;
    }

    // 计算字符串中各字符出现的次数
    vector<int> encode(string s) {
        vector<int> count(26,0);
        for (char c : s) {
            int delta = c - 'a';
            count[delta]++;
        }
        return count;
    }
};
```



# 区间
## 0726
### 228. 汇总区间
给定一个  无重复元素 的 有序 整数数组 nums 。
返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x
```
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        unordered_set<int> set;
        vector<string> res;
        while(i<n){
            int low =i;
            i++;
            while(i<n && nums[i] == nums[i-1]+1){
                i++;
            }
            int high = i-1;
            string temp = to_string(nums[low]);
            if(low<high){
                temp.append("->");
                temp += to_string(nums[high]);
            }
            res.push_back(move(temp));
        }
        return res;
    }
};
```

# 栈
# 链表
# 二叉树
# 二叉树层次遍历
# 二叉搜索树
# 图
# 图的广度优先搜索
# 字典树
# 回溯
# 分治
# Kadane 算法
# 二分查找
# 堆
# 位运算
# 数学
# 一维动态规划
# 多维动态规划




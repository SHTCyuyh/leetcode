# 数组/字符串
## 7.26
### 合并两个有序数组（88）
思路：原地修改，从后往前；注意处理边界条件
```
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i= m-1, j= n-1;
        int p = nums1.size() - 1;     
        while(i>=0 && j>=0){
            if(nums1[i] > nums2[j]){
                nums1[p] = nums1[i];
                i--;
                p--;
            }else{
                nums1[p] = nums2[j];
                j--;
                p--;
            }
        }
        while(j>=0){
            nums1[p] = nums2[j];
            j--;
            p--;
        }
    }
};
```

### 27. 移除元素
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
自己的思路：遇到删除的值就和末位交换（边界条件需要考虑清楚，其次可以调用swap函数）
```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int j = nums.size() - 1;
        for (int i = 0; i <= j; i++) {
            if (nums[i] == val) {
                swap(nums[i], nums[res]);
                i--;
                res--;
            }
        }
        return j + 1;
    }
};
```
正确：快慢指针（原地修改数组，用快指针探路，慢指针存值，删除重复元素类似）；
```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow=0, fast=0;
        while(fast < nums.size()){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```


### 26. 删除有序数组中的重复项
给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。
原地修改： 快慢指针
`注意边界条件`
```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow=0, fast=0;
        while(fast<nums.size()){
            if(nums[fast] != nums[slow]){
                slow++;
                nums[slow] = nums[fast];
                
            }
            fast++;
        }
        return slow+1;
    }
};
```

### 80. 删除有序数组中的重复项 II
给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。
(思路：用一个flag记录出现次数)
```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int count = 0;
        int slow=0,fast=0;
        while(fast<nums.size()){
            if(nums[slow] != nums[fast]){
                slow++;
                nums[slow] = nums[fast];
            }else if(slow < fast && count<2){
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
            count++;
            if(fast<nums.size() && nums[fast]!= nums[fast-1]){
                count = 0;
            }
                
        }
        return slow+1;
    }
};
```

### 169. 多数元素
给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
(思路：set)
```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int n:nums){
            mp[n]++;
            if(mp[n]>int(nums.size()/2))
                return n;
        }
        return 0;
    }
};
```

(进阶：粒子的带点性)
```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int count = 0;
        int target;
        for(int n:nums){
            if(count == 0){
                target = n;
                count = 1;
            }else if(n == target){
                count++;
            }else{
                count--;
            }
        }
        return target;
    }
};

```
### 189. 轮转数组
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数
(思路：迭代器切割,`注意k需要对n取余`)
`vector.assign(begin,end), vector.erase(position),vector.erase(begin,end)`
```
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        vector<int> temp = nums;
        k = k%nums.size();
        auto left_b = nums.begin();
        auto right = temp.end();
        auto new_b = temp.end()-k;
        nums.insert(left_b,new_b,right);
        nums.erase(nums.end()-k,nums.end());
    }
};
```

(其他思路：三次逆转【全部，前半，后半】)
(其他思路：用全新数组存nums[i + k) % n] = nums[i])
```
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> newArr(n);
        for (int i = 0; i < n; ++i) {
            newArr[(i + k) % n] = nums[i];
        }
        nums.assign(newArr.begin(), newArr.end());
    }
};
```
## 0727
### 121. 买卖股票的最佳时机
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
(自己思路：一维动态规划，dp[i][1]表示第i天持有股票的最大收益，返回dp[n][0])
`你只能选择某一天买入！！所以dp[i][1] = max(dp[i-1][1],-prices[i])`
```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n,vector<int>(2));
        for(int i=0;i<n;++i){
            if(i == 0){
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]);
            dp[i][1] = max(dp[i-1][1], -prices[i]);
        }
        return dp[n-1][0];
    }
};
```
### 122. 买卖股票的最佳时机 II
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 。
(自己思路：一维动态规划，dp[i][1]表示第i天持有股票的最大收益，返回dp[n][0])
 `可以多次买卖所以dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])`
 ```
 class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n,vector<int>(2));
        for(int i=0;i<n;++i){
            if(i == 0){
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]);
        }
        return dp[n-1][0];
    }
};
 ```
### 55. 跳跃游戏
给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标
(思路：计算每个位置能到达的最远位置，如果最远位置不能到达当前位置，则false，最后比较最远和size的值)
```
class Solution {
public:
    bool canJump(vector<int>& nums) {
        // vector<int> sup(nums.size());
        if(nums.size()<2) return true;
        int maxdes = nums[0];
        for(int i=1; i<nums.size();++i){
            if(maxdes < i){
                return false;
            }
            maxdes = max(nums[i] + i,maxdes);
        }
        return maxdes>=nums.size()-1;      
        
    }
};
```

### 45. 跳跃游戏 II
给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。
每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处；
0 <= j <= nums[i] 
i + j < n
返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。
（思路：一维动态规划，dp[i]表示到达i位置最小跳跃次数 `错误：应定义成为：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步`，选择从nums[p]中选择1步，2步等）
（正确思路贪心:每次都跳到最远时再计算次数）：
```
class Solution {
public:
    int jump(vector<int>& nums) {
        int end=0,maxdes=0;
        int n = nums.size();
        int times = 0;
        for(int i=0;i<n-1;++i){
            maxdes = max(nums[i]+i, maxdes);
            if(end == i){
                times++;
                end = maxdes;
            }
        }
        return times;
    }
};
```

### 274. H 指数
给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。
根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且每篇论文 至少 被引用 h 次。如果 h 有多种可能的值，h 指数 是其中最大的那个。
（思路：排序+比较定义）
```
class Solution {
public:
    int hIndex(vector<int>& citations) {
        sort(citations.begin(),citations.end());
        int n = citations.size();
        int h=0;
        for(int i =0; i<citations.size();++i){
            int c = min(citations[i], n-i);
            h = max(h,c);
        }
        return h;
    }
};
```

### 380. O(1) 时间插入、删除和获取随机元素
实现RandomizedSet 类：
RandomizedSet() 初始化 RandomizedSet 对象
bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。
bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。
int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同概率 被返回。
你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。
(思路：用set实现所有功能)
`迭代器的使用！！！！！！！`
<font color=red>int len = distance(set.begin(), set.end()); //迭代器的长度</font>
<font color=red>auto it = set.begin()</font> ;
<font color=red>advance(it, k); //迭代器步进；</font>

```
class RandomizedSet {
public:
    unordered_set<int> set;
    RandomizedSet() {
        
    }
    
    bool insert(int val) {
        if(set.count(val)){
            return false;
        }else{
            set.insert(val);
        }
        return true;
    }
    
    bool remove(int val) {
        if(set.count(val)){
            set.erase(val);
            return true;
        }
        return false;
    }
    
    int getRandom() {
        int len = distance(set.begin(), set.end());
        // cout << len << endl;
        int k = rand() % (int(len));
        // cout << k << endl;
        auto it = set.begin() ;
        // unordered_set<int>::iterator it= auto(k) + set.begin();
        advance(it, k);
        return *it;
    }
};
```
### 238. 除自身以外数组的乘积
给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。
题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。
请不要使用除法，且在 O(n) 时间复杂度内完成此题
(思路类似前缀和，把左边乘积和右边成绩计算出来)
```
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> left(n);
        vector<int> right(n);
        int temp = 1;
        left[0] = 1;
        for(int i=1;i<n;++i){
            left[i] = nums[i-1] * left[i-1];
        }
        right[n-1] = 1;
        for(int i=n-2;i>=0;--i){
            right[i] = nums[i+1] * right[i+1];
        }
        vector<int> answer(n);
        for(int i=0; i<n; ++i){
            answer[i] = left[i] * right[i];
        }
        return answer;
    }
};
```
## 0728
### 134. 加油站
在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
(思路：轮转数组，保证gas之和大于cost之和： 超时了)

正确思路：贪心[先判定总油量是否大于cost，然后保证起始后，油箱中一直有油]
```
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        // change(gas,cost);
        int n = gas.size();
        int sum = 0;
        for(int i=0;i<n;++i){
            sum += gas[i] - cost[i];
        }
        if(sum <0)
            return -1;
        int start = 0;
        int tank = 0;
        for(int i=0; i<n; ++i){
            tank += gas[i] - cost[i];
            if(tank < 0){
                tank = 0;
                start = i+1;
            }
        }
        return start==n?-1:start;
    }
};
```
### 135. 分发糖果
n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。
你需要按照以下要求，给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。
相邻两个孩子评分更高的孩子会获得更多的糖果。
请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 
(思路：找到最小的值，然后递归)
（正确：两次遍历，左边规则，右边规则，取较大的值）
origin:| 1 | 3 | 2 | 2 | 1 |
left:| 1 | 2 | 1 | 1 | 1 |
right:| 1 | 2 | 1 | 2 | 1 |
res: | 1 | 2 | 1 | 2 | 1 |
```
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        vector<int> left(n);
        for(int i=0;i<n;++i){
            if(i>0 && ratings[i] > ratings[i-1]){
                left[i] = left[i-1] + 1;
            }else{
                left[i] = 1;
            }
        }
        int right = 0, res = 0;
        for(int i=n-1; i>=0; i--){
            if(i<n-1 && ratings[i] > ratings[i+1]){
                right++;
            }else{
                right = 1;
            }
            res += max(left[i], right);
        }
        return res;
    }
};
```
### 42. 接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
(思路，左边，右边)
（每个柱子的储水量等于`min（左最高，右最高） - height[i]`）
```
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        vector<int> l_max(n);
        vector<int> r_max(n);
        int res = 0;
        l_max[0] = height[0];
        r_max[n-1] = height[n-1];
        for(int i=1; i<n;++i){
            l_max[i] = max(height[i], l_max[i-1]);
        } 
        for(int i=n-2; i>=0;i--){
            r_max[i] = max(height[i], r_max[i+1]);
        }
        for(int i =1; i<n-1; i++){
            res += min(l_max[i],r_max[i]) - height[i];
        }
        return res;
    }
};
```

### 13. 罗马数字转整数
```
class Solution {
public:
    unordered_map<char, int> map = {
        {'I', 1},
        {'V', 5},
        {'X', 10},
        {'L', 50},
        {'C', 100},
        {'D', 500},
        {'M', 1000},
    };
    int romanToInt(string s) {
        int n = s.size();
        int ans = 0;
        for(int i=0; i<s.size(); i++){
            int value = map[s[i]];
            if(i <n-1 && value < map[s[i+1]]){
                ans -= value;
            }else{
                ans += value;
            }
        }
        return ans;
    }
};
```
### 58. 最后一个单词的长度
给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。
单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
（思路：for遍历，注意边界时候要重新赋值）
```
class Solution {
public:
    int lengthOfLastWord(string s) {
        int n = s.size();
        string last = "";
        int res;
        for(char c:s){
            if(c != ' '){
                last += c;
            }else if(last != ""){
                res = last.size();
                last = "";
            }
        }
        res = last==""?res:last.size();
        return res;
    }
};
```

### 14. 最长公共前缀
编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 ""。
```
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if (!strs.size()) {
            return "";
        }
        int length = strs[0].size();
        int count = strs.size();
        for (int i = 0; i < length; ++i) {
            char c = strs[0][i];
            for (int j = 1; j < count; ++j) {
                if (i == strs[j].size() || strs[j][i] != c) {
                    return strs[0].substr(0, i);
                }
            }
        }
        return strs[0];
    }
};
```

## 0729
### 151. 反转字符串中的单词
给你一个字符串 s ，请你反转字符串中 单词 的顺序。
单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。
注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
(思路反转两次)
```
class Solution {
public:
    string reverseWords(string s) {
        vector<string> strs;
        string re_s = reverse(s);
        string temp = "";
        for(char c:re_s){
            if(c != ' '){
                temp += c;
            }else{
                if(temp != ""){
                    strs.push_back(temp);
                    temp = "";
                }
            }
        }
        if(temp != ""){
            strs.push_back(temp);
        }
        string res;

        for(int i=0; i<strs.size();i++){
            string temp = strs[i];
            res += reverse(temp);
            if(i < strs.size()-1){
                res += ' ';
            }
        }
        return res;
    }
    string reverse(string s){
        int n = s.size();
        string res = "";
        for(int i=n-1; i>=0; i--){
            res += s[i];
        }
        return res;
    }
};
```
### 6. N 字形变换
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列
(思路：矩阵存储，然后遍历矩阵 // 或者直接计算位置？)
```
class Solution {
public:
    string convert(string s, int numRows) {
        int n = s.size();
        if(numRows < 2) return s;
        int col = (n/(numRows + numRows-2)+1)*(numRows - 1);
        // cout << col << endl;
        vector<vector<char>> map(numRows,vector<char>(col,' '));
        for(int i=0;i<n;i++){
            int m = (i)/(numRows + numRows-2)*(numRows-1);
            int off = i%(numRows + numRows-2);
            // cout << "m:" << m << ' ' << "off:" << off << ' ' <<"n:"<< numRows<< endl; 
            int index_x,index_y;
            if(off<numRows){
                 index_y = m;
                 index_x = off;
            }else{
                 index_y = m + (off - numRows)+1;
                 index_x = 2* numRows - off - 2;
            }
            cout << index_x << ' ' << index_y << endl;
            // m[]
            map[index_x][index_y] = s[i];
        }
        string res;
        for(int i=0;i<numRows;++i){
            for(int j=0; j<col; ++j){
                char c = map[i][j];
                // m[i][j] = '1';
                // cout << c << endl;
                if(c != ' '){
                    res += c;
                }
            }
        }
        return res;
    }
};
```
### 28. 找出字符串中第一个匹配项的下标
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。
（思路：切割子串直接比较）
```
class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.size();
        int m = needle.size();
        int flag = 0;
        while(n>=m){
            if(haystack[0] != needle[0]){
                haystack = haystack.substr(1,n-1);
                flag++;
                n = haystack.size();
            }else{
                string sub = haystack.substr(0,m);
                if(sub==needle){
                    return flag;
                }else{
                    haystack = haystack.substr(1,n-1);
                    flag++;
                    n = haystack.size();
                }
            }
            
        }
        return -1;
    }
};
```
### 68. 文本左右对齐
给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。
你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。
要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。
文本的最后一行应为左对齐，且单词之间不插入额外的空格。
`fill_n(back_inserter(ans), 1, ' '); back_inserter迭代器末尾 注意和end()区别`
`fill_n(位置，数量，填充元素)`
```
    std::vector<int> v1{ 1, 2, 3, 4, 5, 6};
    std::vector<int> v2{ 1, 2, 3, 4, 5, 6 };

    *(v1.end()-1) = 10;
    *(std::back_inserter(v2)) = 10;

    v1: 1   2       3       4       5       10

    v2: 1   2       3       4       5       6       10
```
```
class Solution {
public:
    string fillWords(vector<string>& words, int bg, int ed, int maxWidth, bool lastLine = false)
    {
        int wordCount = ed - bg + 1;
        int spaceCount = maxWidth + 1 - wordCount;
        for (int i = bg; i <= ed; i++)
        {
            spaceCount -= words[i].size();
        }

        int spaceSuffix = 1;
        int spaceAvg = (wordCount == 1) ? 1 : spaceCount / (wordCount - 1);
        int spaceExtra = (wordCount == 1) ? 0 : spaceCount % (wordCount - 1);

        string ans;
        for (int i = bg; i < ed; i++)
        {
            ans += words[i];
            if (lastLine)
            {
                fill_n(back_inserter(ans), 1, ' ');
                continue;
            }
            fill_n(back_inserter(ans), spaceSuffix + spaceAvg + ((i - bg) < spaceExtra), ' ');
        }
        ans += words[ed];
        fill_n(back_inserter(ans), maxWidth - ans.size(), ' ');
        return ans;
    }

    vector<string> fullJustify(vector<string>& words, int maxWidth) 
    {
        vector<string> ans;
        int cnt = 0;
        int bg = 0;
        for (int i = 0; i < words.size(); i++)
        {
            cnt += words[i].size() + 1;

            if (i + 1 == words.size() || cnt + words[i + 1].size() > maxWidth)
            {
                ans.push_back(fillWords(words, bg, i, maxWidth, i + 1 == words.size()));
                bg = i + 1;
                cnt = 0;
            }
        }
        return ans;
    }
    
};
```
# 双指针
## 7.26
### 125. 验证回文串
如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。
`注意大小写的转化可以用加减法实现c = c-'A'+'a';`
`回文串的判定可以从两边往中间，也可以中间往两边，奇偶的情况可能需要讨论`
```
class Solution {
public:
    bool isPalindrome(string s) {
        string ss = "";
        for(char c:s){
            if(c >= 'a' && c <= 'z'){
                ss += c;
            }
            if(c >= '0' && c <= '9'){
                ss += c;
            }
            if(c >= 'A' && c <= 'Z'){
                c = c-'A'+'a';
                ss += c;
            }
        }
        int i= 0, j= ss.size()-1;
        while(i<j){
            if(ss[i] == ss[j]){
                i++;
                j--;
            }else{
                return false;
            }
        }
        return true;
    }
};
```
### 392. 判断子序列
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
```
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i=0,j=0;
        while(i<s.size() && j<t.size()){
            if(s[i] == t[j]){
                i++;
                j++;
            }else{
                j++;
            }
        }
        if(i == s.size()){
            return true;
        }
        return false;
    }
};
```

### 167. 两数之和 II - 输入有序数组
给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 
以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。
思路（1.暴力双指针：超时；2：用hash表去存值，但是没有利用输入的性质）
```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left=0,right=numbers.size()-1;
        vector<int> res(2);
        unordered_map<int, int> mp;
        for(int i=0;i<numbers.size();i++){
            if(mp.count(target-numbers[i])){
                // cout << target-numbers[i] << endl;
                res[0] = mp[target-numbers[i]]+1;
                res[1] = i+1;
                break;
            }else{
                mp[numbers[i]] = i;
            }
        }
        return res;
    }
};
```
左右指针，利用二分查找的思想
```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        for (int i = 0; i < numbers.size(); ++i) {
            int low = i + 1, high = numbers.size() - 1;
            while (low <= high) {
                int mid = (high - low) / 2 + low;
                if (numbers[mid] == target - numbers[i]) {
                    return {i + 1, mid + 1};
                } else if (numbers[mid] > target - numbers[i]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
        }
        return {-1, -1};
    }
};
```



# 滑动窗口
## 0726
### 209. 长度最小的子数组
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

思路：滑动窗口枚举所有满足条件的子数组，然后用全局变量维护最小长度。
其他思路：因为所有数都是正数，可以尝试使用前缀和+二分查找的方法
```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res=INT_MAX;
        int left=0,right=0;
        int sum = 0;
        while(right < nums.size()){
            sum += nums[right];
            right++;
            if(sum >= target){
                int len = right-left;
                res = min(len+1,res);
                // cout << sum << endl;
                while(sum >= target && left<=right){
                    sum -= nums[left];
                    left++;
                    res = min(right-left+1,res);
                }
            }
        }
        return res==INT_MAX?0:res;

    }
};
```

### 3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
思路：用一个set来记录窗口内的字符出现频率，用一个全局变量维护最长长度
`注意一些细节`
```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size()<1){
            return s.size();
        }
        int res = 1;
        unordered_map<char,int> window;
        int left=0,right=0;
        while(right<s.size()){
            char c = s[right];
            window[c]++;
            while(window[c]>1){
                char d = s[left];
                window[d]--;
                left++;
                res = max(res,right-left+1);
            }
            res = max(res,right-left+1);
            right++;
            
        }
        return res;
    }
};
```

# 矩阵
## 0726
### 36. 有效的数独
请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
(思路：遍历)
```
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int rows[9][9];
        int columns[9][9];
        int subboxes[3][3][9];
        
        memset(rows,0,sizeof(rows));
        memset(columns,0,sizeof(columns));
        memset(subboxes,0,sizeof(subboxes));
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c != '.') {
                    int index = c - '0' - 1;
                    rows[i][index]++;
                    columns[j][index]++;
                    subboxes[i / 3][j / 3][index]++;
                    if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
};
```
# 哈希表
## 0726
### 383. 赎金信
你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
如果可以，返回 true ；否则返回 false 。
（思路）：hash表记录出现的元素，验证
```
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map<char,int> mp;
        for(char c:magazine){
            mp[c]++;
        }
        for(char c:ransomNote){
            if(mp[c] == 0)
                return false;
            mp[c]--;
        }
        return true;
    }
};
```

### 205. 同构字符串
给定两个字符串 s 和 t ，判断它们是否是同构的。
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。
(用两个mp分别记录a->b,b->a的映射)
```
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        unordered_map<char,char> mp;
        unordered_map<char,char> mp2;
        for(int i=0;i<s.size();++i){
            char c = s[i];
            char d = t[i];
            if(!mp.count(c) && !mp2.count(d)){
                mp[c] = d;
                mp2[d] = c;
            }else{
                if(mp[c] != d || mp2[d] != c)
                    return false;
            }
        }
        return true;
    }
};
```

### 290. 单词规律
给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。
这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。
(用两个mp记录映射关系)
```
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        vector<string> ss;
        string temp = "";
       for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' ') {
                ss.push_back(temp);
                temp = "";
            } else {
                temp += s[i];
            }
        }
        ss.push_back(temp);

        unordered_map<char,string> p2s;
        unordered_set<string> set;
        if (pattern.size() != ss.size()) {
            return false;
        }
        for(int i=0;i<pattern.size();++i){
            if(!p2s.count(pattern[i])){
                if(set.count(ss[i])){
                    return false;
                }
                p2s[pattern[i]] = ss[i];
                set.insert(ss[i]);
            }else{
                if(p2s[pattern[i]] != ss[i])
                    return false;
            }
        }
        return true;
    }
};

```

### 242. 有效的字母异位词
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

 (思路，hash map存，判断最后是否为空)
 ```
class Solution {
public:
    bool isAnagram(string s, string t) {
        unordered_map<char,int> mp;
        for(char c:s){
            mp[c]++;
        }
        for(char c:t){
            if(!mp.count(c)){
                return false;
            }else{
                mp[c]--;
                if(mp[c]==0){
                    mp.erase(c);
                }
            }
        }
        if(mp.begin() != mp.end()){
            return false;
        }
        
        return 1;
    }
};
 ```
`优化方法，encode用数组记录每个字符出现次数`
```
class Solution {
public:
    // 判断字符串 s 和 t 是否为字母异位词
    bool isAnagram(string s, string t) {
        // 使用 encode 函数计算两个字符串中各字符出现的次数
        vector<int> count1 = encode(s);
        vector<int> count2 = encode(t);
        // 判断两个字符串中所有字符出现的数量是否相同
        for (int i = 0; i < count1.size(); i++) {
            if (count1[i] != count2[i]) {
                return false;
            }
        }
        return true;
    }

    // 计算字符串中各字符出现的次数
    vector<int> encode(string s) {
        vector<int> count(26,0);
        for (char c : s) {
            int delta = c - 'a';
            count[delta]++;
        }
        return count;
    }
};
```



# 区间
## 0726
### 228. 汇总区间
给定一个  无重复元素 的 有序 整数数组 nums 。
返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x
```
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        unordered_set<int> set;
        vector<string> res;
        while(i<n){
            int low =i;
            i++;
            while(i<n && nums[i] == nums[i-1]+1){
                i++;
            }
            int high = i-1;
            string temp = to_string(nums[low]);
            if(low<high){
                temp.append("->");
                temp += to_string(nums[high]);
            }
            res.push_back(move(temp));
        }
        return res;
    }
};
```

# 栈
# 链表
# 二叉树
# 二叉树层次遍历
# 二叉搜索树
# 图
# 图的广度优先搜索
# 字典树
# 回溯
# 分治
# Kadane 算法
# 二分查找
# 堆
# 位运算
# 数学
# 一维动态规划
# 多维动态规划




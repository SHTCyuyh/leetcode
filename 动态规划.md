### 面试题 17.24. 最大子矩阵
给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。
返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。
(思路：最大子数组和的扩展，dp[i]表示以i结束的最大子数组)
```
class Solution {
public:
    vector<int> getMaxMatrix(vector<vector<int>>& matrix) {
        int m = matrix.size(),n = matrix[0].size();
        int maxMat = INT_MIN;
        vector<int> ans(4,-1);

        for(int r1=0;r1<m;++r1){
            vector<int> nums(n);
            for(int r2=r1;r2<m;++r2){
                int dp=0, start=-1;
                for(int i=0;i<n;++i){
                    nums[i] += matrix[r2][i];
                    // cout << "r2 i" << r2 << i << endl;
                    // cout << nums[i] << endl;
                    if(dp>0){
                        dp += nums[i];
                    }
                    else{
                        dp=nums[i];
                        start = i;
                    }
                    if(dp > maxMat){
                       maxMat=dp;
                       ans[0]=r1;
                       ans[1]=start;
                       ans[2]=r2;
                       ans[3]=i; 
                    }
                }
            }
        }
    return ans;
    }
};
```

### 面试题 17.23. 最大黑方阵
给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。
返回一个数组 [r, c, size] ，其中 r, c 分别代表子方阵左上角的行号和列号，size 是子方阵的边长。若有多个满足条件的子方阵，返回 r 最小的，若 r 相同，返回 c 最小的子方阵。若无满足条件的子方阵，返回空数组。
(思路：判断dp[i][j]==>根据dp[i-1][j],dp[i][j-1])
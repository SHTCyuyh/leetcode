# 0-1 背包问题
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少
```
明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。
```
基本框架
* ![avatar](fig/3.29DP.png)
明确「状态」： 就是「背包的容量」和「可选择的物品」。
明确「选择】： 选择就是「装进背包」或者「不装进背包」嘛
定义 dp 数组：dp[i][w]对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。
```
for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            dp[i-1][w],  //不把物品 i 装进背包，最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。
            dp[i-1][w - wt[i-1]] + val[i-1]//如果你把这第 i 个物品装入了背包，那么 dp[i][w] 应该等于 val[i-1] + dp[i-1][w - wt[i-1]]。
        )
return dp[N][W]
```
# 子集背包问题

```
3.31 分割等和子集(416)
```
* 可以转化为背包问题，相当于有两个sum/2的背包；把nums恰好放入
* dp[i][w]表示把i放入w的背包中，刚好放进就返回true 否则返回false


# 完全背包问题